// Discord Poster for Reddit Posts
// Adapts Reddit format to match Discord embeds

const { Client, GatewayIntentBits, EmbedBuilder } = require('discord.js');

class DiscordPoster {
  constructor(botToken, channelId) {
    this.botToken = botToken;
    this.channelId = channelId;
    this.client = new Client({
      intents: [GatewayIntentBits.Guilds]
    });
    this.ready = false;
  }

  async connect() {
    if (this.ready) return;
    
    return new Promise((resolve, reject) => {
      this.client.once('ready', () => {
        console.log(`Discord bot logged in as ${this.client.user.tag}`);
        this.ready = true;
        resolve();
      });
      
      this.client.once('error', reject);
      this.client.login(this.botToken).catch(reject);
    });
  }

  async disconnect() {
    if (this.ready) {
      await this.client.destroy();
      this.ready = false;
    }
  }

  async postRedditReport(post, replySuggestions) {
    const channel = await this.client.channels.fetch(this.channelId);
    if (!channel) {
      throw new Error('Discord channel not found');
    }

    const embed = new EmbedBuilder()
      .setColor(this.getSubredditColor(post.subreddit))
      .setTitle(`ðŸ”¥ r/${post.subreddit.toUpperCase()}`)
      .setURL(post.url)
      .setDescription(this.formatPostText(post.title, post.text))
      .setAuthor({
        name: `u/${post.author}`,
        iconURL: 'https://www.redditstatic.com/desktop2x/img/favicon/favicon-32x32.png'
      })
      .addFields(
        { name: 'â¬†ï¸ Upvotes', value: post.metrics.upvotes.toLocaleString(), inline: true },
        { name: 'ðŸ’¬ Comments', value: post.metrics.comments.toLocaleString(), inline: true },
        { name: 'ðŸ“Š Score', value: post.metrics.score.toLocaleString(), inline: true }
      )
      .setTimestamp(new Date(post.createdAt))
      .setFooter({ text: `Viral Score: ${post.viralScore.toLocaleString()}` });

    // Add reply suggestions as fields
    replySuggestions.forEach((reply, index) => {
      embed.addFields({
        name: `ðŸ’¡ Reply Option ${index + 1}`,
        value: reply
      });
    });

    await channel.send({ embeds: [embed] });
  }

  async postHeader(hour, timeLabel) {
    const channel = await this.client.channels.fetch(this.channelId);
    
    const embed = new EmbedBuilder()
      .setColor(0xFF4500) // Reddit orange
      .setTitle(`ðŸ“Š Viral Reddit Report`)
      .setDescription(`Top posts from crypto subreddits\nðŸ• ${timeLabel}`)
      .setTimestamp();

    await channel.send({ embeds: [embed] });
    await channel.send('â”€'.repeat(40));
  }

  async postFooter() {
    const channel = await this.client.channels.fetch(this.channelId);
    await channel.send('â”€'.repeat(40));
    await channel.send('*Report generated by The Department of Quietly Getting Things Done*');
  }

  formatPostText(title, text) {
    const fullText = text && text !== title ? `${title}\n\n${text}` : title;
    if (fullText.length > 400) {
      return fullText.substring(0, 397) + '...';
    }
    return fullText;
  }

  getSubredditColor(subreddit) {
    const colors = {
      'CryptoCurrency': 0xFF4500,  // Reddit orange
      'ethtrader': 0x627EEA,       // ETH blue
      'Chainlink': 0x375BD2,       // LINK blue
      'defi': 0x00D395             // DeFi green
    };
    return colors[subreddit.toLowerCase()] || 0x6366F1;
  }
}

module.exports = DiscordPoster;
